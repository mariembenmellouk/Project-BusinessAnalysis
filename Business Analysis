#!/usr/bin/env python
# coding: utf-8
import pandas as pd
# Step 1: Import the data into a DataFrame with headers
df = pd.read_excel(r"c:\Users\merie\OneDrive\Bureau\WGU\D598\Task2\New folder\D598 Data Set.xlsx.xlsx")
import matplotlib.pyplot as plt
import seaborn as sns

# Visualization

# Bar Chart for Mean Debt to Equity Ratio by Business State
plt.figure(figsize=(10, 8))
mean_debt_to_equity = df.groupby('Business State')['Debt to Equity'].mean().sort_values()
mean_debt_to_equity.plot(kind='bar', color='pink')
plt.title('Mean Debt to Equity Ratio by Business State')
plt.xlabel('Business State')
plt.ylabel('Mean Debt to Equity Ratio')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Boxplot of Total Revenue by Business State
plt.figure(figsize=(10, 8))
sns.boxplot(x='Business State', y='Total Revenue', data=df, palette='dark')
plt.title('Total Revenue Distribution by Business State')
plt.xlabel('Business State')
plt.ylabel('Total Revenue')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Pie Chart of Proportion of Businesses by Business State
plt.figure(figsize=(10,10))
business_count_by_state = df['Business State'].value_counts()
business_count_by_state.plot(kind='pie', autopct='%1.1f%%', startangle=90, colors=sns.color_palette('pastel'))
plt.title('Proportion of Businesses by Business State')
plt.ylabel('')  
plt.show()

# Scatter Plot for Total Liabilities vs. Total Long-term Debt
plt.figure(figsize=(10, 15))
sns.scatterplot(x='Total Long-term Debt', y='Total Liabilities', hue='Business State', data=df, palette='pastel')
plt.title('Total Liabilities vs Total Long-term Debt by Business State')
plt.xlabel('Total Long-term Debt')
plt.ylabel('Total Liabilities')
plt.legend(title='Business State', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()


# Step 2: Check for duplicates
duplicates = df[df.duplicated()]
if len(duplicates) > 0:
    print(f"Number of duplicates: {len(duplicates)}")
    print("Duplicates found:")
    print(duplicates)
    # Handle duplicates (e.g., removing them)
    df = df.drop_duplicates()
else:
    print("No duplicates found.")

# Step 3: Group data by 'Business State' and calculate statistics
grouped_by_state = df.groupby('Business State').agg({
    'Total Long-term Debt': ['mean', 'median', 'min', 'max'],
    'Total Equity': ['mean', 'median', 'min', 'max'],
    'Debt to Equity': ['mean', 'median', 'min', 'max'],
    'Total Liabilities': ['mean', 'median', 'min', 'max'],
    'Total Revenue': ['mean', 'median', 'min', 'max'],
    'Profit Margin': ['mean', 'median', 'min', 'max']
})

# Store results in a new DataFrame
grouped_by_state.columns = ['_'.join(col).strip() for col in grouped_by_state.columns.values]
grouped_by_state_df = grouped_by_state.reset_index()

print("Grouped statistics by Business State:")
print(grouped_by_state_df)

# Step 4: Filter with negative debt-to-equity ratios
negative_debt_to_equity = df[df['Debt to Equity'] < 0]

# Step 5: Identify underperforming companies
if not negative_debt_to_equity.empty:
    print("Underperforming companies with negative debt-to-equity ratio:")
    print(negative_debt_to_equity)
    # Make recommendations for improvement 
    print("Recommendations for improvement: reduce debt or increase equity.")
else:
    print("No underperforming companies found.")

# Step 6: Compute debt-to-income ratio for each business
df['Debt to Income Ratio'] = df['Total Long-term Debt'] / df['Total Revenue']

# Step 7: Concatenate the Debt-to-Income Ratio DataFrame with the original DataFrame
final_df = pd.concat([df, df[['Business ID', 'Debt to Income Ratio']]], axis=1)

print("Final DataFrame with Debt-to-Income Ratios:")
print(final_df[['Business ID', 'Business State', 'Debt to Income Ratio']])
